# Write a New Target
Targets are the reason we're all here. Targets represent an arbitrary prediction endpoint, somewhere Counterfot can submit inputs and get a response. Like other objects in Counterfit, targets should inherit from a baseclass `counterfit.core.targets.Target`. 

## Create the Target
1. Start Counterfit
2. Execute the `new` command and follow the prompts.
3. Open the new target file in a text editor.

The `new` command will build an empty target file ready for you to fill out. Counterfit will also load this target into the current session.

```python

# Generated by counterfit #

from counterfit.core.targets import Target

class Newtarget(Target):
    target_name = "newtarget"
    target_data_type = "image"
    target_endpoint = ""
    target_input_shape = ()
    target_output_classes = []
    target_classifier = ""
    X = []

    def load(self):
        self.X = []

    def predict(self, x):
        return x

```

Building a new target against an unknown endpoint is something of a discovery process. To help with this interactive process, Counterfit provides some helpful commands. For example, the `reload` command.

4. Update the `load` function to print `loaded!`
5. Execute the `reload --target` command

```python
    def load(self):
        print("\nloaded!\n")
        self.X = []
```

Anytime you make a change to a target, execute `reload --target` to load the new version of the target. Pretty neat. There are other commands like `predict`, but first we need an endpoint to query. For now, let's use a model from a demo target.

6. Go into the `counterfit/targets/digits_blackbox` folder, and copy both `mnist_784.npz` and `mnist_sklearn_pipeline.pkl` into `counterfit/targets/newtarget` folder.

Great. We have a local model and some data. Counterfit expects a target to provide some information about a target. Counterfit uses this information to populate the interface, and attacks use the information to correctly reshape inputs. 


## Create a Local Target
7. Go ahead a fill out the `NewTarget` with the following information,

```python
class Newtarget(Target):
    target_name = "newtarget"
    target_data_type = "image"
    target_endpoint = "mnist_sklearn_pipeline.pkl"
    target_input_shape = (1, 28, 28)
    target_output_classes = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]
    target_classifier = "BlackBox"
    X = []
```

Here is a quick recap of each property, 

- `target_name` and `target_data_type` were selected during target creation. These are used to identify the target in the interface, and match relevant attacks to the target.
- `target_endpoint` is where Counterfit should submit inputs.
- `target_input_shape` is used by frameworks, or the target to reshape data appropriately if needed.
- `target_output_classes` are the known labels of the target endpoint, at a minimum these are `[0, 1]` (is not a thing, is a thing). 
- `target_classifier` is a conveience property that can be used by a framework to further integrate. 
- `X` is a place holder for sample data.


The first function targets are required to implement is a `load()` function. This function is called when a user executes the `interact` command. It should load models, data, or anything else required. Since we're using a local model, this is straight forward.

7. Replace the `load` function with the function below.

```python

    def load(self):
        with open(self.fullpath(self.target_endpoint), "rb") as f:
            self.model = pickle.load(f)

        sample_data = np.load(self.fullpath("mnist_784.npz"), allow_pickle=True)
        self.X = sample_data["X"]
```

8. Add the required imports to the top of the file. Remember to `reload --target` to make sure the data loads properly.

```python
# Generated by counterfit #
import pickle
import numpy as np
```

Finally, it's time to write the `predict` function. The predict function will recieve an input from an attack algorithm and should submit it to the `target_endpoint`, then return a list of proabilities. These probabilities are required for attack algorithms to work properly. However, while algorithms work with arrays of numbers, targets found in-the-wild take actual images, blocks of text, or some other array of abstract properties. Which means additional processing inside the `predict` function could be necessary, as you will see later in this guide. For now, we'll continue with the local model. 

9. Replace the `predict` function with the following, 

```python
    def predict(self, x):
        x = np.array(x)
        scores = self.model.predict_proba(x.reshape(x.shape[0], -1))
        # return a list of class probabilities; each row must be the same length as target_output_classes
        return scores.tolist() # []
```
 
Once again, `reload --target` to load the latest changes. Next, test the `predict` function and execute the `predict -i 0` command. This command sends a single sample to the `target_endpoint`. If you are happy with the inputs and outputs, you are ready to scan. Next, lets host the model on a web endpoint.

## Create an Online Target
1. Replace the current target with this new one.

```python


# Generated by counterfit #
import numpy as np
import base64
import requests
from PIL import Image
from io import BytesIO

from counterfit.core.targets import Target

class Newtarget(Target):
    target_name = "newtarget"
    target_data_type = "image"
    target_endpoint = "http://127.0.0.1:8080/score"
    target_input_shape = (1, )
    target_output_classes = ["0", "1"] # [!=5, 5]
    target_classifier = "BlackBox"
    X = []

    def load(self):
        image = Image.open("counterfit/targets/newtarget/sample_5.png")
        image_array = np.array(image)
        self.X = [np.array(image)]
        self.target_input_shape = self.target_input_shape + image_array.shape

    def predict(self, x):
        for sample in x:
            img = Image.fromarray(sample)
            im_file = BytesIO()
            img.save(im_file, format="PNG")
            im_bytes = im_file.getvalue()  # im_bytes: image in binary format.
            im_b64 = base64.b64encode(im_bytes).decode()

            results  = requests.post(self.target_endpoint, json={"image": im_b64})
            results_json = results.json()

            score = [1-results_json["conf"], results_json['conf']]
            return score

```

11. Write a simple web endpoint to host a model.

```python
from flask import Flask, request
from PIL import Image
import logging
import pickle
import json
import base64
import numpy as np
from io import BytesIO
from PIL import Image

class ModelServer:
    def __init__(self, model_file) -> None:
        with open(model_file, "rb") as f:
            self.model = pickle.load(f)

    def start_server(self):
        log = logging.getLogger('werkzeug')
        log.disabled = False

        app = Flask(__name__)
        @app.route('/score', methods=["POST"])
        def score():            
            image_data = request.json
            image_bytes = base64.b64decode(image_data["image"])
            image_file = BytesIO(image_bytes)
            image = Image.open(image_file)
            image_array = np.array(image)

            scores = self.predict(image_array)
            return json.dumps(scores)
            
        app.run(port=8080)


    def predict(self, x):
        scores = self.model.predict_proba(x.reshape(1, -1))
        label = np.argmax(scores).tolist()
        conf = scores.tolist()[0][label]
        return {"label": label, "conf": conf}


model = ModelServer("./mnist_sklearn_pipeline.pkl")
model.start_server()
```




# Write a new Framework
A major component of Counterfit is a framework. If you want to redefine, wrap, or create a new framework knowing how Counterfit handles frameworks is important. Before we start, it is important to note that Counterfit is not a framework, frameworks exist outside of Counterfit. While you go through this tutorial, it will think of your framework as separate from Counterfit.

A framework is really just a container for attack algos. In the case of Augly, Adversarial Robustness Toolbox, and TextAttack, you load the relevant attack class from whatever module it lives in. For example, to load the `HopSkipJump` attack, loading code should find `art.attacks.evasion.hop_skip_jump.HopSkipJump`. Similarly for TextAttack, to load the `DeepWordBug` attack, loading code should find `textattack.attack_recipes.deepwordbug_gao_2018.DeepWordBugGao2018`. Fortunately, most frameworks implement attacks by extending some base class, which makes finding the in a module much easier. The easiest however, is to load a module you write yourself! 


1. Create a new `custom` folder under `counterfit/frameworks`. In that folder, create a new `custom.py` file.
2. Add a `CustomAttack` class.

```python
class CustomAttack:
    def __init__(self) -> None:
        pass
```

Attack algorithms in most frameworks have two major components, a target, and some way to iteratively submit inputs and retrive outputs from the target.

3. Update `CustomAttack` to recive a predict function in the `__init__`
4. Write a `query` function that prints an input and the output.

```python
class CustomAttack:
    def __init__(self, predict) -> None:
        self.predict = predict
        self.query_budget = 10

    def generate(self, input):
        for i in self.query_budget:
            output = self.predict(input)
            print(input)
            print(output)
```

Now that we have a base attack to work with, we can build wrap into Counterfit. 

2. Import the parent class `from counterfit.core.frameworks import Framework`.
3. Write a new `CustomFramework` class. 

``` python
from counterfit.core.frameworks import Framework

class CustomFramework(Framework):
    def __init__(self):
        super().__init__()

    def load(self):
        pass

    def build(self):
        pass

    def run(self):
        pass
```

Frameworks require you implement a number of functions. These functions have mirrored functions in `CFState` that the interface uses. For example, when a user executes `load custom`, it calls into `CFState.state().load_framework`, which in turn calls `CustomFramework.load()`. Build and run are similar, 

- `use custom` -> `CFState.state().build_new_attack()` -> `CustomFramework.build()`
- `run` -> `CFState.state().run_attack()` -> `CustomFramework.run()`

In this case loading the attack is simple as it lives in the same file as the framework. To add an attack to a framework, use the `add_attack` function with the required parameters. Ensure arguments are of the right type. 

5. Replace the `load()` function with the below function,

```python
    def load(self):
        self.add_attack(
            attack_name="custom",
            attack_class=CustomAttack,
            attack_category="BlackBox",
            attack_type="evasion",
            attack_data_tags=["tabular"],
            attack_default_params={"query_budget": 10}
        )
```

`add_attack` loads all the information into a `namedtuple`. This is an immutable structure and ensure users can't accidently change something after loading a framework. Counterfit also uses this information in the terminal.

Next, the framework should `build()` the attack. This function should return an attack ready to run. 

```python 
    def build(self, target, attack):
        new_attack = attack(target.predict)
        return new_attack
```

The returned attack is wrapped into a `CFAttack` object. `CFAttack` is an aggregation that is used for the rest of the attack lifecycle. It contains `CFAttackOptions`, a reference to the target, initial samples, and other important items. 

A framework should impement a `run` function. This function should execute the attack. The restults are stored in the `CFAttack` for reference later. 

```python
    def run(self, cfattack):
        results = cfattack.attack.generate(cfattack.samples)
        return results
```

Finally, a framework should implement a `check_success` function. This function should return a bool value indicating whether or not the attack was successful. 

```python
    def check_success(self, cfattack):
        for result in cfattack.results:
            final_labels = cfattack.target.outputs_to_labels(result)
            if np.array(cfattack.initial_labels) != final_labels:
                print("\nAttack was successful\n")
                return True
        print("\nAttack was not successful\n")
        return False
```

Given that the attack doesn't actually make any changes to the inputs, we expect this to fail. 



# Add a Command
Counterfit defines a number of basic commands that are kept in `counterfit/commands`. Commands are addded to the terminal (`counterfit.core.terminal.Terminal`) during startup. Users are encouraged to add custom commands, redefine other commands, etc. For this tutorial we will create a `target` command to define target interactions. The steps are the same for all new commands, 

1. Create a `target.py` file in `counterfit/commands`.
2. Add the required imports.
3. Add the cmd2 decorators.
3. Write the `do_target` logic.

Before writing the `do_target` logic, the `target` command should look like the following,

```python
import argparse
from cmd2 import with_argparser
from cmd2 import with_category

from counterfit.core.state import CFState

parser = argparse.ArgumentParser()
parser.add_argument("-l", "--list", action="store_true", help="Start the new target wizard")

@with_argparser(parser)
@with_category("Counterfit Commands")
def do_target(self, args: argparse.Namespace) -> None:
    """Defines target interactions.
    """
```

Commands use `CFState` as the central interaction broker, to this end `CFState` has a lot of useful functions.

```python
def do_target(self, args: argparse.Namespace) -> None:
    """Defines target interactions.
    """
    targets = CFState.state().list_targets()
    print(targets)
```

Finally, use `reload --commands` to reload the `target` command into the session, then execute `targets -l`. You should see a list of targets displayed in the terminal.


# Write a New Logger
Loggers like every other object in Counterfit are loaded based on their parent class. Logging is a fairly simple task

1. Open `counterfit/logging/logging.py`. There are 3 basic classes ready for use, `DefaultLogger`, `ListLogger`, and a `JSONLogger`. 
2. Copy the `DefaultLogger` class and paste it at the bottom of the file. 
3. Make basic changes to the new logger, 
    - Import `csv` module at the top of the file.
    - Change the class to `CSVLogger`
    - Update the description.

Your new `CSVLogger` should look like the following, 

```python
import csv
from counterfit.core.attacks import CFAttackLogger

class CSVLogger(CFAttackLogger):
    """Logs queries to a CSV file saved to disk.
    """
    def __init__(self, **kwargs):
        self.num_queries = 0

    def log(self, item):
        self.num_queries += 1
```

Before we implement the logic to actually write logs to a CSV file. First, let's get an idea of what is sent to the logger. The `predict_wrapper` function in `counterfit/core/targets.py` is responsible for logging, all target `predict` functions are wrapped into this function for logging (or other custom logic required by the user). Looking at the `log_entry` dictionary we can see the values sent to the logger, additional values could be added if needed. 

- `timestamp`
- `input`
- `output`
- `labels`

_Remember, the `predict` function is the interface between an attack algo and the target model, attack algos use this function to submit inputs and get outputs._

```python
def predict_wrapper(self, x, **kwargs):
    output = self.predict(x)
    if self.logger:
        labels = self.outputs_to_labels(output)
        for sample, tmp_output in zip(x, output):
            try:
                log_entry = {
                    "timestamp": datetime.datetime.utcnow().strftime("%a, %d %b %Y %H:%M:%S GMT"),
                    "input": np.array(sample).flatten().reshape(-1).tolist(),
                    "output": tmp_output,
                    "labels": labels
                }
                self.logger(log_entry)

            except Exception as e:
                print(e)
                continue

    return output
```

Back to our `CSVLogger`.

1. Update the __init__ function to take and store a  `filename` property.
2. Update the __call__ function to write an entry to the output file.
3. Make sure to serialize numpy outputs with `orjson`.

```python
import orjson
import csv
from counterfit.core.attacks import CFAttackLogger

class CSVLogger(CFAttackLogger):
    """Logs queries to a CSV file saved to disk.
    """
    def __init__(self, filename):
        self.num_queries = 0
        self.filename = f"{filename}/logs.csv"

    def log(self, item):
        with open(self.filename, "a+") as log_file:
            writer = csv.writer(log_file)

            input_data = orjson.dumps(
                item['input'],
                option=orjson.OPT_SERIALIZE_NUMPY
            ).decode()

            output_data = orjson.dumps(
                item['output'],
                option=orjson.OPT_SERIALIZE_NUMPY
            ).decode()

            label_data = orjson.dumps(
                item['labels'],
                option=orjson.OPT_SERIALIZE_NUMPY
            ).decode()

            writer.writerow([
                item['timestamp'],
                input_data,
                output_data,
                label_data
            ])
            self.num_queries += 1
```

The last change to make before testing is to update `attack_logger_obj_map` in the `get_attack_logger_obj` factory funtion. Simply add `CSVLogger` to the `attack_logger_obj_map` dictionary.
```python
    attack_logger_obj_map = {
        'default': DefaultLogger,
        'list': ListLogger,
        'json': JSONLogger,
        'csv': CSVLogger
    }
```

Finally, it's time for testing. Start Counterfit, `interact` with a target, `use` attack, and `set --logger csv` before executing `run`.