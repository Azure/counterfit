import numpy as np
import tqdm
from zipfile import ZipFile
from counterfit.core.targets import ArtTarget
from counterfit.core import config
import requests
import os
import json
import time


MLSEC_API = 'https://api.mlsec.io/api'
MLSEC_SUBMIT_API = f'{MLSEC_API}/ml_submit_sample' + '?api_token={api_token}' + '&model={models}'  # POST
MLSEC_RETRIEVE_API = f'{MLSEC_API}/ml_get_sample' + '?api_token={api_token}' + '&jobid={jobid}'  # GET
ALL_MODELS = ["rwchsfde", "ymtspdyt", "fmbuylrn", "vftuemab", "qhdyuvnv", "amsqr", "tlgwdpam"]
SLEEP_DURATION = 0.500  # in seconds

ZIP_END_POINT = 'https://mlsec.io/static/MLSEC_2021_malware.zip'


def download_samples_to(filename):
    r = requests.get(ZIP_END_POINT)
    if r.ok:
        print(f"\n[+] Successfully downloaded malware samples to the location {filename}\n")
        # open method to open a file on your system and write the contents to the file location specified
        with open(filename, "wb") as code:
            code.write(r.content)
    else:
        print(r.status_code)


class MlsecMalware(ArtTarget):
    model_name = "mlsecmalware"
    model_data_type = "pe"
    model_endpoint = MLSEC_API
    model_input_shape = (1, )
    model_output_classes = [0, 1]

    sample_input_path = f"{config.targets_path}/mlsecmalware/mlsec_malware_samples.zip"
    encryption_password = b'infected'

    X = []
    zip_info = []

    target_models = ALL_MODELS

    def __init__(self):
        if not os.path.exists(self.sample_input_path):
            download_samples_to(self.sample_input_path)

        print(f"scanning malware sample info from {self.sample_input_path}")
        with ZipFile(self.sample_input_path) as thezip:
            thezip.setpassword(self.encryption_password)
            for zipinfo in tqdm.tqdm(thezip.infolist()):
                self.zip_info.append(zipinfo)

        self.X = self.read_input_data()
    
    def read_input_data(self):
        out = []
        with ZipFile(self.sample_input_path) as thezip:
            for i in range(len(self.zip_info)):
                with thezip.open(self.zip_info[i], pwd=self.encryption_password) as thefile:
                    out.append(thefile.read())
        return out

    def set_attack_samples(self, index=0):
        # JIT loading of samples
        if hasattr(index, "__iter__"):
            # list of indices
            to_fetch = index
        else:
            to_fetch = [index]

        out = []
        
        for i in to_fetch:
            out.append(self.X[i])
        self.active_attack.sample_index = index
        self.active_attack.samples = out

    def submit_single(self, bytez):
        if type(bytez) is np.ndarray or type(bytez) is np.bytes_:
            bytez = bytez.item()

        query = MLSEC_SUBMIT_API.format(models=",".join(self.target_models), api_token=os.getenv('API_TOKEN'))

        resp = requests.post(url=query, data=bytez, headers={'Content-Type': 'application/octet-stream'})

        assert resp.ok, f'POST error {resp.status_code}: {resp.text}'

        # retrieve jobid
        try:
            r = resp.json()
            jobid = r['jobid']
        except (json.JSONDecodeError, KeyError) as e:
            raise Exception(resp.text)

        # fetch the results, retrying as necessary
        while True:
            resp = requests.get(MLSEC_RETRIEVE_API.format(jobid=jobid, api_token=os.getenv('API_TOKEN')))
            if resp.status_code != 202:
                break
            time.sleep(SLEEP_DURATION)

        assert resp.ok, f'GET error {resp.status_code}: {resp.text}'
        r = resp.json()
        return [r[m]['result'] for m in self.target_models]  # return list of respones for queried models

    def __call__(self, x):
        scores = []

        for sample in x:
            s = np.mean(self.submit_single(sample))
            scores.append([1-s, s])

        return np.array(scores)
