import os
import numpy as np
import magic
import gzip
import shutil

from counterfit.core import config
from secml.array import CArray
from secml_malware.attack.blackbox.c_wrapper_phi import CEmberWrapperPhi
from secml_malware.models import CClassifierEmber
from counterfit.core.targets import SecMLMalwareTarget
from zipfile import ZipFile
import tqdm


class EmberTarget(SecMLMalwareTarget):
    model_name = 'ember-secml'
    model_data_type = "PE"
    model_output_classes = ["benign", "malicious"]
    model_input_shape = (1,)
    model_location = "local"
    model_endpoint = os.path.join(
        config.targets_path, 'pe_malware', 'pretrained', 'ember_model.txt')

    sample_input_path = f"{config.targets_path}/pe_malware/samples/MLSEC_samples.zip"
    encryption_password = b'infected'

    X = []

    def __init__(self):
        if not os.path.isfile(self.model_endpoint):
            # gunzip if necessary
            with gzip.open(self.model_endpoint + '.gz', 'rb') as f_in:
                with open(self.model_endpoint, 'wb') as f_out:
                    shutil.copyfileobj(f_in, f_out)
        model = CClassifierEmber(self.model_endpoint)
        self.model = CEmberWrapperPhi(model)

        # store all competition malware samples in memory...
        # ...to make this possible, saving as a list of bytez w/o padding
        print(f"reading malware samples from {self.sample_input_path}")
        with ZipFile(self.sample_input_path) as thezip:
            thezip.setpassword(self.encryption_password)
            for zipinfo in tqdm.tqdm(thezip.infolist()):
                with thezip.open(zipinfo, pwd=self.encryption_password) as thefile:
                    x_i = thefile.read()
                    self.X.append(x_i)

    def __call__(self, batch):
        # 'batch' can be a list of bytes or a CArray
        def helper(xx):
            xx = xx.atleast_2d()
            labels, scores = self.model.predict(xx, return_decision_function=True)
            labels, scores = labels.atleast_2d(), scores.atleast_2d()

            return labels.tondarray(), scores.tondarray()

        try:

            labels, scores = [], []
            if type(batch) is list or type(batch) is np.ndarray:  # we store nominally as a list of bytez (without padding) for memory efficiency
                for xx in batch:
                    if type(xx) is bytes or type(xx) is np.bytes_:
                        # bytes is nominal, however, after adversarial examples are collected, we receive a list of CArrays that need no conversion
                        xx = CArray(np.frombuffer(xx, dtype='uint8'))
                    l, s = helper(xx)
                    labels.append(l.item())
                    scores.append(s[0])
            elif type(batch) is CArray:  # secml requires CArray
                batch = batch.atleast_2d()
                for i in range(batch.shape[0]):
                    l, s = helper(batch[i, :])
                    labels.append(l.item())
                    scores.append(s[0])

        except (AttributeError, IndexError):
            from IPython import embed
            embed()

        return CArray(labels).tondarray(), CArray(scores).tondarray()